# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013, Alec Thomas
# This file is distributed under the same license as the Injector package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Injector 0.22.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-15 11:35+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../scopes.rst:4
msgid "Scopes"
msgstr "スコープ"

#: ../../scopes.rst:7
msgid "Singletons"
msgstr "シングルトン"

#: ../../scopes.rst:9
msgid "Singletons are declared by binding them in the SingletonScope. This can be done in three ways:"
msgstr "シングルトンは SingletonScope でバインドすることによって宣言されます。これには 3 つの方法があります。"

#: ../../scopes.rst:11
msgid "Decorating the class with `@singleton`."
msgstr "クラスを `@singleton` で修飾します。"

#: ../../scopes.rst:12
msgid "Decorating a `@provider` decorated Module method with `@singleton`."
msgstr "`@provider` で修飾されたモジュールメソッドを `@singleton` で修飾します。"

#: ../../scopes.rst:13
msgid "Explicitly calling `binder.bind(X, scope=singleton)`."
msgstr "明示的に `binder.bind(X, scope=singleton)` を呼び出します。"

#: ../../scopes.rst:15
msgid "A (redundant) example showing all three methods::"
msgstr "3 つすべての方法を示す (冗長な) 例::"

#: ../../scopes.rst:27
msgid "If using hierarchies of injectors, classes decorated with `@singleton` will be created by and bound to the parent/ancestor injector closest to the root that can provide all of its dependencies."
msgstr "インジェクターの階層を使用する場合、`@singleton` で修飾されたクラスは、そのすべての依存関係を提供できるルートに最も近い親/祖先インジェクターによって作成され、バインドされます。"

#: ../../scopes.rst:30
msgid "Implementing new Scopes"
msgstr "新しいスコープの実装"

#: ../../scopes.rst:32
msgid "In the above description of scopes, we glossed over a lot of detail. In particular, how one would go about implementing our own scopes."
msgstr "上記のスコープの説明では、多くの詳細を省略しました。特に、独自のスコープを実装する方法についてです。"

#: ../../scopes.rst:34
msgid "Basically, there are two steps. First, subclass `Scope` and implement `Scope.get`::"
msgstr "基本的に、2 つのステップがあります。まず、`Scope` をサブクラス化し、`Scope.get` を実装します::"

#: ../../scopes.rst:41
msgid "Then create a global instance of :class:`ScopeDecorator` to allow classes to be easily annotated with your scope::"
msgstr "次に、クラスがスコープで簡単に注釈付けできるように、:class:`ScopeDecorator` のグローバルインスタンスを作成します::"

#: ../../scopes.rst:46
msgid "This can be used like so::"
msgstr "これは次のように使用できます::"

#: ../../scopes.rst:52
msgid "Scopes are bound in modules with the :meth:`Binder.bind_scope` method::"
msgstr "スコープは、:meth:`Binder.bind_scope` メソッドを使用してモジュールにバインドされます::"

#: ../../scopes.rst:58
msgid "Scopes can be retrieved from the injector, as with any other instance. They are singletons across the life of the injector::"
msgstr "スコープは、他のインスタンスと同様にインジェクターから取得できます。インジェクターの存続期間中はシングルトンです::"

#: ../../scopes.rst:64
msgid "For scopes with a transient lifetime, such as those tied to HTTP requests, the usual solution is to use a thread or greenlet-local cache inside the scope. The scope is \"entered\" in some low-level code by calling a method on the scope instance that creates this cache. Once the request is complete, the scope is \"left\" and the cache cleared."
msgstr "HTTP リクエストに結び付けられているスコープなど、一時的な存続期間を持つスコープの場合、通常はスコープ内でスレッドまたは greenlet ローカルキャッシュを使用します。スコープは、このキャッシュを作成するスコープインスタンスのメソッドを呼び出すことによって、いくつかの低レベルコードで「入力」されます。リクエストが完了すると、スコープは「終了」し、キャッシュはクリアされます。"

